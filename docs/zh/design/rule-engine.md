# 规则引擎与分析系统

> **文档目的**: 挥杆分析规则引擎的实现和未来 ML 升级路径
>
> **阅读对象**: 算法工程师、产品经理

---

## 算法不训练 vs 训练后的区别

### 不训练模型 (MVP Phase A)

使用现成的开源模型 + 规则引擎:

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                    MVP: 规则引擎方案                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  输入 ──→ MediaPipe (预训练) ──→ 关节坐标 ──→ 规则判断 ──→ 反馈        │
│                                                                          │
│  规则示例:                                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ IF 肩部旋转 < 80° THEN 问题 = "转肩不足"                         │   │
│  │ IF 下杆时间 / 上杆时间 < 2.5 THEN 问题 = "节奏过快"              │   │
│  │ IF 髋部启动时间 > 肩部启动时间 THEN 问题 = "下杆顺序错误"         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  优点: 快速开发,可解释,不需要训练数据                                   │
│  缺点: 阈值需要手动调整,无法适应个人差异                                 │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**规则引擎完整实现示例:**

```python
def analyze_swing_with_rules(vision_feat, imu_feat, emg_feat):
    """
    规则引擎:基于生物力学阈值分析挥杆
    这不是任何特殊包,就是 IF-THEN 代码!
    """
    problems = []
    suggestions = []
    score = 100

    # ═══════════════════════════════════════════════════════════════
    # 规则1: 肩膀旋转检查
    # ═══════════════════════════════════════════════════════════════
    if vision_feat['shoulder_rotation'] < 85:
        problems.append(f"转肩不足 ({vision_feat['shoulder_rotation']:.0f}°,应 >85°)")
        suggestions.append("上杆时让左肩指向球,感受背部拉伸")
        score -= 15

    # ═══════════════════════════════════════════════════════════════
    # 规则2: 髋部旋转检查
    # ═══════════════════════════════════════════════════════════════
    if vision_feat['hip_rotation'] < 40:
        problems.append(f"髋部旋转不足 ({vision_feat['hip_rotation']:.0f}°,应 >40°)")
        suggestions.append("场下练习:髋部拉伸,增加活动度")
        score -= 10

    # ═══════════════════════════════════════════════════════════════
    # 规则3: X-因子检查 (肩-髋分离)
    # ═══════════════════════════════════════════════════════════════
    if vision_feat['x_factor'] < 35:
        problems.append(f"X-因子过小 ({vision_feat['x_factor']:.0f}°,应 >35°)")
        suggestions.append("上杆时保持下盘稳定,让肩膀多转")
        score -= 10

    # ═══════════════════════════════════════════════════════════════
    # 规则4: 挥杆节奏检查
    # ═══════════════════════════════════════════════════════════════
    if imu_feat['tempo_ratio'] < 2.5:
        problems.append(f"下杆节奏太快 ({imu_feat['tempo_ratio']:.1f}:1,理想 3:1)")
        suggestions.append("上杆数1-2-3,下杆数4,保持节奏")
        score -= 10

    if imu_feat['tempo_ratio'] > 4.0:
        problems.append(f"下杆节奏太慢 ({imu_feat['tempo_ratio']:.1f}:1)")
        suggestions.append("下杆可以更果断,但保持顺畅")
        score -= 5

    # ═══════════════════════════════════════════════════════════════
    # 规则5: 核心激活检查 (EMG独特价值!)
    # ═══════════════════════════════════════════════════════════════
    if emg_feat['core_activation'] < 50 and emg_feat['forearm_activation'] > 60:
        problems.append("核心激活不足,手臂代偿")
        suggestions.append("场下训练:平板支撑 3x60秒,俄罗斯转体 3x20")
        score -= 20  # 这是最严重的问题!

    # ═══════════════════════════════════════════════════════════════
    # 规则6: 发力时序检查 (核心应先于手臂)
    # ═══════════════════════════════════════════════════════════════
    if not emg_feat['activation_sequence_correct']:
        problems.append("发力时序错误:手臂先于核心")
        suggestions.append("练习从髋部启动下杆的感觉")
        score -= 15

    return {
        'score': max(0, score),
        'problems': problems,
        'suggestions': suggestions,
        'raw_features': {**vision_feat, **imu_feat, **emg_feat}
    }
```

**SDK/API 可用性:** 🛠️ 自己写 IF-THEN 代码,无需任何外部包

---

## 训练自定义模型 (Phase B+)

收集数据 → 微调/训练 → 更准确的预测:

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                    Phase B+: 训练模型方案                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  数据收集                                                                │
│     ↓                                                                    │
│  标注 (专业教练标记好/坏挥杆)                                             │
│     ↓                                                                    │
│  训练 (微调 MMPose/ViTPose 或训练分类器)                                  │
│     ↓                                                                    │
│  导出 ONNX                                                               │
│     ↓                                                                    │
│  部署到 App                                                              │
│                                                                          │
│  训练选项:                                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ 选项1: 微调姿态模型 (需要关节点标注, 工作量大)                    │   │
│  │ 选项2: 训练分类器 (在姿态特征上训练, 推荐) ✅                     │   │
│  │ 选项3: 端到端模型 (视频→评分, 需要大量数据)                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  优点: 更准确,可个性化,竞争壁垒                                         │
│  缺点: 需要数据收集,需要ML专业知识                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 相关文档

- [传感器数据格式规范](sensor-data-formats.md) - 输入数据的格式定义
- [多模态融合算法](fusion-algorithm.md) - 特征提取方法
- [反馈系统与 Ghost 指导](feedback-system.md) - 分析结果的输出呈现

---

**最后更新**: 2025年12月11日
